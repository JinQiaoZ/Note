# 事务隔离级别(Isolation Level)

> **隔离级别与并发性是互为矛盾的**

![图片](https://img10.360buyimg.com/img/jfs/t30082/42/674125047/338074/2435ab67/5bfaa69dN64b7af52.jpg)

**隔离程度越高，数据库的并发性越差；隔离程度越低，数据库的并发性越好**

|隔离级别|Read Uncommitted(未提交读)|Read Committed(提交读)|Repeatable Read(可重复读)|Serializable(可串行化)|
|:-: |:-: |:-: |:-: |:-: |
|**脏读(Dirty Read)** |Y |- |- |-
|**丢失更新(Lost Update)** |Y |Y |- |-
|**不可重复读(NonRepeatable Read)** |Y |Y |- |-
|**幻读(Phantom Read)** |Y |Y |Y |-
|**默认级别数据库** |- |Oracle，SQL Server |MySQL(InnoDB) |-
|**并发性能** |最高 |第二 |第三 |最低

## 不考虑事务的隔离性

如果不考虑事务的隔离性，那么会发生下面所示的问题

* **脏读(Dirty Read)**

所谓脏读是指**一个事务中访问到了另外一个事务未提交的数据**

当一个事务读取另一个事务尚未提交的修改时，产生脏读

* **丢失更新(Lost Update)**

当系统允许两个事务同时更新同一数据时，**后一个事务拿到了前一个事务的中间状态数据(一个事务的更新操作被另外一个事务的更新操作所覆盖)**，一个事务的更新覆盖了其它事务的更新结果导致丢失更新

1. 第一类丢失更新，回滚丢失，隔离级别可以解决
2. 第二类丢失更新，覆盖丢失/两次更新问题，只能通过锁解决，[乐观锁或悲观锁](01-DB-Lock.html)

* **不可重复读(NonRepeatable Read)**

同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生不可重复读

通俗解释是指**在同一个事务内根据同一个条件对行记录(同一条数据)进行多次查询，但是搜出来的结果(数据)却不一致**，发生不可重复读的原因是在多次搜索期间查询条件覆盖的数据被其他事务修改了

* **幻读(Phantom Read)**

同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻像读

通俗解释是指**同一个事务内多次查询返回的结果集不一样(比如增加了或者减少了行记录)**

> **幻读和不可重复读的区别**，幻读和不可重读读都是读取了另一个事务中已经提交的数据，不同的是不可重复读多次查询的都是同一个数据项，针对的是对同一行数据进行修改(Update)或删除(Delete)，而幻读针对的是一个数据整体(数据的条数)，主要是插入(Insert)操作  
> **比如**，同一个事务A内第一次查询时候有N条记录，但是第二次同等条件下查询却又N+1条记录，这就好像产生了幻觉，为啥两次结果不一样。其实和不可重复读一样，发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据。不同在于不可重复读是同一个记录的数据内容被修改了，幻读是数据行记录变多了或者少了

## Read Uncommitted(未提交读)

读取未提交内容，在该隔离级别，**所有事物都可以看到其它未提交事务的执行结果**，即在未提交读级别，事务中的修改，即使没有提交，对其他事务也都是可见的，该隔离级别很少用于实际应用。**读取未提交的数据，也被称之为脏读(Dirty Read)**。该隔离级别最低，并发性能高

## Read Committed(提交读)

读取提交内容，这是大多数数据库默认的隔离级别。它满足了隔离的简单定义，**一个事务只能看见已经提交事务所做的改变**。换句话说，一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的

## Repeatable Read(可重复读)

**可重复读可以确保同一个事务，在多次读取同样数据的时候，得到同样的结果**。可重复读解决了脏读的问题，不过理论上，这会导致另外一个棘手的问题，幻读(Phantom Read)。MySQL中的InnoDB和Falcon存储引擎通过MVCC(Multi-Version Concurrency Control，多版本并发控制)机制解决了该问题，需要注意的是，多版本控制只是解决了不可重复读的问题，而加上间隙锁(也就是它这里所谓的并发控制)才解决了幻读问题

## Serializable(可串行化)

序列化，这是最高的隔离级别，它通过**强制事务排序，强制事务串行执行**，从而解决幻读问题，简而言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的等待超时和锁竞争，实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑使用这个隔离级别，这是花费代价最高但是最可靠的隔离级别

#### 最后

1. 感谢lhrbest的事务的4种隔离级别(Isolation Level)分别是什么: [http://blog.itpub.net/26736162/viewspace-2638951](http://blog.itpub.net/26736162/viewspace-2638951)
2. 感谢Jade_K的事务隔离级别(IsolationLevel): [https://www.cnblogs.com/wms01/p/6183241.html](https://www.cnblogs.com/wms01/p/6183241.html)
3. 感谢阿里加多的何为脏读、不可重复读、幻读: [https://www.jianshu.com/p/f7ac1b22e899](https://www.jianshu.com/p/f7ac1b22e899)