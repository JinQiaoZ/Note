(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{232:function(v,_,e){"use strict";e.r(_);var a=e(0),o=Object(a.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("hr"),v._v(" "),e("h3",{attrs:{id:"概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[v._v("#")]),v._v(" 概念")]),v._v(" "),e("ul",[e("li",[v._v("如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的")])]),v._v(" "),e("h3",{attrs:{id:"工作原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#工作原理"}},[v._v("#")]),v._v(" 工作原理")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("JVM")]),v._v("有一个"),e("code",[v._v("Main Memory")]),v._v("，而每个线程有自己的"),e("code",[v._v("Working Memory")]),v._v("，一个线程对一个变量进行操作时，都要在自己的"),e("code",[v._v("Working Memory")]),v._v("里面建立一个"),e("code",[v._v("Copy")]),v._v("，操作完之后再写入"),e("code",[v._v("Main Memory")]),v._v("。多个线程同时操作同一个变量，就可能会出现不可预知的结果。所以，当线程一起并发运行时，同时对一个数据进行修改，就可能会造成数据的不一致性(多个线程先后更改数据造成所得到的数据是脏数据)")])]),v._v(" "),e("h3",{attrs:{id:"解决方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[v._v("#")]),v._v(" 解决方法")]),v._v(" "),e("blockquote",[e("p",[v._v("多线程并发不安全的原因已经知道，那么针对这个种情况，有两种解决思路")])]),v._v(" "),e("ul",[e("li",[v._v("给共享的资源加把锁，保证每个资源变量每时每刻至多被一个线程占用")]),v._v(" "),e("li",[v._v("让线程也拥有资源(副本)，不用去共享进程中的资源(副本)")])]),v._v(" "),e("blockquote",[e("p",[v._v("基于上面的两种思路，下面便是三种实施方案")])]),v._v(" "),e("ul",[e("li",[v._v("多实例或者是多副本("),e("code",[v._v("ThreadLocal")]),v._v(")，对应着思路二，"),e("code",[v._v("ThreadLocal")]),v._v("可以为每个线程的维护一个私有的本地变量，可参考"),e("code",[v._v("Java")]),v._v("线程副本–"),e("code",[v._v("ThreadLocal")])]),v._v(" "),e("li",[v._v("使用锁机制"),e("code",[v._v("synchronize")]),v._v("或"),e("code",[v._v("lock")]),v._v("方式，为资源加锁")]),v._v(" "),e("li",[v._v("使用"),e("code",[v._v("java.util.concurrent")]),v._v("下面的类库，有"),e("code",[v._v("JDK")]),v._v("提供的线程安全的集合类")])]),v._v(" "),e("h4",{attrs:{id:"线程安全的集合对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程安全的集合对象"}},[v._v("#")]),v._v(" 线程安全的集合对象")]),v._v(" "),e("ul",[e("li",[v._v("Vector")]),v._v(" "),e("li",[v._v("HashTable")]),v._v(" "),e("li",[v._v("StringBuffer")])]),v._v(" "),e("h4",{attrs:{id:"非线程安全的集合对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非线程安全的集合对象"}},[v._v("#")]),v._v(" 非线程安全的集合对象")]),v._v(" "),e("ul",[e("li",[v._v("ArrayList")]),v._v(" "),e("li",[v._v("LinkedList")]),v._v(" "),e("li",[v._v("HashMap")]),v._v(" "),e("li",[v._v("HashSet")]),v._v(" "),e("li",[v._v("TreeMap")]),v._v(" "),e("li",[v._v("TreeSet")]),v._v(" "),e("li",[v._v("StringBulider")])]),v._v(" "),e("h3",{attrs:{id:"线程安全和线程不安全的小例子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程安全和线程不安全的小例子"}},[v._v("#")]),v._v(" 线程安全和线程不安全的小例子")]),v._v(" "),e("ul",[e("li",[v._v("在单线程运行的情况下，如果"),e("code",[v._v("Size = 0")]),v._v("，添加一个元素后，此元素在位"),e("code",[v._v("0")]),v._v("，而且"),e("code",[v._v("Size = 1")])]),v._v(" "),e("li",[v._v("如果是在多线程情况下，比如有两个线程，"),e("code",[v._v("线程A")]),v._v("先将元素存放在位置0。但是此时"),e("code",[v._v("CPU")]),v._v("调度"),e("code",[v._v("线程A")]),v._v("暂停，"),e("code",[v._v("线程B")]),v._v("得到运行的机会。"),e("code",[v._v("线程B")]),v._v("也向此"),e("code",[v._v("ArrayList")]),v._v("添加元素，因为此时"),e("code",[v._v("Size")]),v._v("仍然等于"),e("code",[v._v("0")]),v._v("(注意哦，我们假设的是添加一个元素是要两个步骤哦，而"),e("code",[v._v("线程A")]),v._v("仅仅完成了步骤1)，所以"),e("code",[v._v("线程B")]),v._v("也将元素存放在"),e("code",[v._v("位置0")]),v._v("。然后"),e("code",[v._v("线程A")]),v._v("和"),e("code",[v._v("线程B")]),v._v("都继续运行，都增加"),e("code",[v._v("Size")]),v._v("的值。那好，现在我们来看看"),e("code",[v._v("ArrayList")]),v._v("的情况，元素实际上只有一个，存放在位置"),e("code",[v._v("0")]),v._v("，而"),e("code",[v._v("Size")]),v._v("却等于"),e("code",[v._v("2")]),v._v("。这就是"),e("code",[v._v("线程不安全")]),v._v("了")])])])}),[],!1,null,null,null);_.default=o.exports}}]);